/*

这是一个经典的0-1背包问题，可以使用动态规划来解决。以下是C++代码实现：

*/

#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N, V;
    cin >> N >> V;
    vector<int> v(N), w(N);
    for (int i = 0; i < N; ++i) {
        cin >> v[i] >> w[i];
    }

    vector<int> dp(V + 1, 0);

    for (int i = 0; i < N; ++i) {
        for (int j = V; j >= v[i]; --j) {
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        }
    }

    cout << dp[V] << endl;
    return 0;
}

/*

### 代码解释：
1. **输入部分**：
   - `N` 是物品的数量，`V` 是背包的容量。
   - `v[i]` 和 `w[i]` 分别表示第 `i` 件物品的体积和价值。

2. **动态规划数组 `dp`**：
   - `dp[j]` 表示容量为 `j` 的背包所能装下的最大价值。
   - 初始时，`dp[j]` 都为 0，表示没有任何物品时，背包的最大价值为 0。

3. **动态规划过程**：
   - 对于每个物品 `i`，我们尝试将其放入背包中。
   - 对于每个容量 `j`，如果 `j >= v[i]`，则可以选择放入物品 `i`，此时 `dp[j]` 更新为 `dp[j - v[i]] + w[i]`，即放入物品 `i` 后的最大价值。
   - 由于每个物品只能使用一次，所以我们从大到小遍历容量 `j`，以避免重复放入同一个物品。

4. **输出结果**：
   - 最终 `dp[V]` 就是容量为 `V` 的背包所能装下的最大价值。

### 时间复杂度：
- 外层循环遍历物品，内层循环遍历容量，因此时间复杂度为 `O(N * V)`。

### 空间复杂度：
- 使用了一维数组 `dp`，空间复杂度为 `O(V)`，满足题目要求的空间限制。

### 示例输入输出：

/*
输入：
4 5
1 2
2 4
3 4
4 5

输出：
8

/*

在这个例子中，选择第2件和第3件物品（体积分别为2和3，价值分别为4和4），总价值为8，是最大值。

*/