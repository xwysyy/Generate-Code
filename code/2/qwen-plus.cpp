/*

为了在有限的空间内解决这个问题，我们可以使用动态规划的方法来实现0-1背包问题。这里的关键是使用一维数组来优化空间复杂度。下面是具体的代码实现：

*/

#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N, V;
    cin >> N >> V;

    vector<int> v(N), w(N);
    for (int i = 0; i < N; ++i) {
        cin >> v[i] >> w[i];
    }

    vector<int> dp(V + 1, 0);

    for (int i = 0; i < N; ++i) {
        for (int j = V; j >= v[i]; --j) {
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        }
    }

    cout << dp[V] << endl;

    return 0;
}

/*

### 代码解释
1. **输入部分**:
   - 读取物品数量 `N` 和背包容量 `V`。
   - 读取每个物品的体积 `v` 和价值 `w`。

2. **动态规划数组 `dp`**:
   - `dp[j]` 表示容量为 `j` 时的最大价值。
   - 初始化 `dp` 数组为 `0`，表示初始状态下背包为空，价值为 `0`。

3. **动态规划过程**:
   - 外层循环遍历每个物品。
   - 内层循环从后向前遍历背包容量，确保每个物品只被使用一次。
   - 更新 `dp[j]` 为当前容量下的最大价值。

4. **输出结果**:
   - 最终 `dp[V]` 即为背包容量为 `V` 时的最大价值。

### 空间优化
- 使用一维数组 `dp` 而不是二维数组，将空间复杂度从 `O(N*V)` 优化到 `O(V)`。
- 内层循环从后向前遍历，避免了重复计算和状态覆盖的问题。

### 时间复杂度
- 时间复杂度为 `O(N*V)`，其中 `N` 是物品数量，`V` 是背包容量。

这个实现方法在时间和空间上都进行了优化，适用于题目给定的约束条件。

*/